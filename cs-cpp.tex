\section{C++}

\subsection{extern}
\begin{lstlisting}
#ifdef __cplusplus
extern "C" {
#endif

char *strcpy(char *, const char*);
// ...

#ifdef __cplusplus
}
#endif
\end{lstlisting}

~extern "C"~ is used to use a C header file in a C++ project.  It is
called linkage convention.  C++ supports overload, but C does not.
C++ typically add more to a function name.  If this is the case, C++
will not find the correct C library because it looks for a different
name.  By using this, during the linkage, the compiler will look for
the original name, i.e. using C linkage method.



\subsection{Class}
\subsubsection{Constructor}

\paragraph{auto-gen by compiler}

 If you don't write, the compiler will generate:
\begin{itemize}
\item a copy constructor
\item a copy assignment operator
\item a destructor
\item a default constructor(if you defined no constructors at all)
\end{itemize}

\begin{lstlisting}
 class A {
 public:
   A() {...} // default
   A(const A& rhs) {...} // copy
   ~A() {...} // destructor
   A& operator=(const A& rhs) {...} // copy assignment operator
 };
\end{lstlisting}

But they are generated only if they are needed.
For the ~operator=~, compiler will generate it iff:
\begin{itemize}
\item resulting code is legal
\item reasonable to make sense
\end{itemize} 
 e.g.
\begin{lstlisting}
 class A {
 private:
   std::string &name;
   const int num;
 };
\end{lstlisting}

 compiler will reject to generate ~operator=~ because when doing
 assignment, should the reference be modified?  \textit{C++ doesn't
   allow make a reference refer to another object.} Should the
 referred string be modified? It will affect other objects!  It is not
 legal to modify a const member either.  If you want to support copy
 assignment in the class containing reference or const, you must
 define it yourself.

\paragraph{explicitly disallow the auto-gen}

\begin{itemize}
\item /link time solution/: Declare the copy constructor and the copy
  assignment operator private.  So that compiler will not generate,
  outside can not see them.  However, member and friend functions can
  still call them.
\item /compile time solution/: Inheritate from =Uncopyable= class who
  declared but didn't define the copy constructor and assginment
  operator.  This works because the compiler will try to generate copy
  constructor and copy assignment when anybody tries to copy it, but
  will of course fail.  It will give error says no instance of copy
  instructor implemented, in other word you can't pass compilation.
\end{itemize}

\begin{lstlisting}
 class Uncopyable {
 protected:
   Uncopyable() {}
   ~Uncopyable() {}
 private:
   Uncopyable(const Uncopyable&);
   Uncopyable& operator=(const Uncopyable&);
 };
 class A : private Uncopyable {}
\end{lstlisting}

\paragraph{Copy Constructor \& Copy Assignment Operator}

\begin{lstlisting}
   class A {
   public:
     A();
     A(const A& rhs); // copy constructor
     A& operator=(const A& rhs) { // copy assignment operator
       return *this; // should return *this
     }
   };

   A a1; // default constructor
   A a2(a1); // copy constructor
   a1 = a2; // copy assignment operator
   A a3 = a2; // copy constructor
\end{lstlisting}

if new object is being defined, a constructor has to be called.
That's why ~a3~ is not calling a copy assignment operator.

copy constructor matters because it defines how an object is **passed
by value**.  In particular, pass-by-value means "call the copy
constructor".

\paragraph{Copy-and-swap Idiom}
To create an exception safe implementation of overloaded assignment operator.
The copy assignment opeartor implementation can cause two kinds of
unsafety:
\begin{itemize}
\item self-assignment unsafe
\item exception unsafe
\end{itemize}

Self-assignment should be properly handled.
It can appear often, e.g.
\begin{itemize}
\item a[i] = a[j]; in the case i=j,
\item *px = *py;
\end{itemize}

The following code explain the two kinds of unsafe.
\begin{itemize}
\item self-assignment unsafe:
  ~rhs.pa~ is already deleted if ~rhs == this~
\item exception unsafe:
  if exception happens during new, pa will contains a pointer to a deleted A.
\end{itemize}


\begin{lstlisting}
    class A {};
    class B {
     private:
      A * pa;
    };
    B& B::operator=(const B& rhs) {
      if (this == &rhs) return * this; // get rid of self-assignment unsafe
      delete pa;
      pa = new A(* rhs.pa);
      return * this;
    }
\end{lstlisting}

the copy and swap is:
\begin{quote}
Create a temporary and swap idiom acquires new resource before it forfeits its current resource.
To acquire the new resource, it uses RAII idiom.
If the acquisition of the new resource is successful, it exchanges the resources using the non-throwing swap idiom.
Finally, the old resource is released as a side effect of using RAII in the first step.
\end{quote}

The code follows:
\begin{lstlisting}
    class B {
      // use std::swap?
      void swap(B& rhs) {
        std::swap(xx,rhs.xx);
      }
    };
    // v1: explicitly create new. BAD
    B& B::operator=(const B& rhs) {
      B tmp(rhs);
      swap(tmp);
      return * this;
    }
    // v2: use pass-by-value as temporary value. GOOD.
    // better optimization
    B& B::operator=(B rhs) {
      swap(rhs);
      return * this;
    }
\end{lstlisting}

\paragraph{Move Constructor \& Move Assignment Opeartor}
\begin{itemize}
\item Move constructor enables you to implement move semantics, which
  can significantly improve the performance of your applications.
\item Move semantics enables you to write code that transfers
  resources (such as dynamically allocated memory) from one object to
  another.
\item Move semantics works because it enables resources to be
  transferred from temporary objects that cannot be referenced
  elsewhere in the program.
\end{itemize}

To implement move semantics, you typically provide a move constructor,
and optionally a move assignment operator (operator=), to your class.
Copy and assignment operations whose sources are rvalues then
automatically take advantage of move semantics.
Reference: Move Constructors and Move Assignment Operators from
Microsoft
\footnote{https://msdn.microsoft.com/en-us/library/dd293665.aspx}.

Move Constructor Example:
\begin{lstlisting}
  // Rvalue Reference
  MemoryBlock(MemoryBlock&& other) : _data(nullptr) , _length(0) {
    // copy
    _data = other._data;
    _length = other._length;
    // set source object fields to default, to avoid multiple free
    other._data = nullptr;
    other._length = 0;
  }
\end{lstlisting}

Move Assignment Operator Example:
\begin{lstlisting}
  MemoryBlock& operator=(MemoryBlock&& other) {
    // avoid self-assignment
    if (this != &other) {
      // Free the existing resource.
      delete[] _data;
      // Copy the data pointer and its length from the 
      // source object.
      _data = other._data;
      _length = other._length;
      // Release the data pointer from the source object so that
      // the destructor does not free the memory multiple times.
      other._data = nullptr;
      other._length = 0;
    }
    return *this;
  }
\end{lstlisting}

\paragraph{explicit constructor}
The explicit prevents the class from being used to perform implicit type conversions,
though they may still be used for explicit type conversions.
Always declare it explicit unless you have a good reason
for allowing a constructor to be used for implicit type conversions.

\begin{lstlisting}
 class A {
 public:
   explicit A(int x=0, bool b=true);
   explicit A(char c); // non-default can also have explicit
 };
 void func(A a);

 A a1;
 func(a1); // ok
 A a2(20); // ok
 func(20); // error, cannot convert int to A implicitly
 func(A(20)); // use B constructor to explicit convert
\end{lstlisting}
\paragraph{initialization}
 
Default Constructor: One that can be called /without any arguments/ is
called /default constructor/.  Compilers will automatically call
default constructors for data members of user-defined types when those
data members are not on initialization list.

Initialization: Data members that are const or references must be
initialized; they cant be assigned.  Do /NOT/ call constructors within
each other.  If init is too many, move them into a private function,
and call the function in all constructors.

The initialization orders are defined by: Base classes are initialized
before derived classes; within a class, data members are initialized
in the order in which they declared, not the position in
initialization list.

I did a test for the copy constructor:

\begin{lstlisting}
#include <iostream>

class A {
public:
  A() {}
  ~A() {}
  int get() {return a;}
  void set(int aa) {
    a = aa;
  }
private:
  int a = 8;
};

int main() {
  A *a = new A();
  a->set(9);
  A *b = new A(*a);
  std::cout << a->get()  << "\n";
  std::cout << b->get() << "\n";
}
\end{lstlisting}

Both the outputs are 9, so the initialization ~a=8~ is not called when
doing copy construction

\subsubsection{virtual}
\paragraph{Bottom Line}
\begin{itemize}
\item polymorphic base classes should declare virtual destructors.
  If a class has virtual functions, it should have virtual destructor
\item Classes should not have virtual destructor if it is not
  designed to be
  \begin{itemize}
  \item  base class, or
  \item  used polymorphically
  \end{itemize}
\end{itemize}
\paragraph{Description}
~Factory Function~: a function that returns a base class pointer to a
newly-created derived class object.

\begin{lstlisting}
 class TimeKeeper {
 public:
   TimeKeeper();
   virtual ~TimeKeeper(); // must have the virtual, or disaster
 };
 class AtomicClock : public TimeKeeper {};
 class WaterClock : public TimeKeeper {};
 class WristWatch : public TimeKeeper {};

 TimeKeeper *getTimeKeeper(); // can return any one

 TimeKeeper *ptk = getTimeKeeper();
 // ...
 delete ptk;
\end{lstlisting}

If no virtual, the ~delete ptk~ will call the destructor of
TimeKeeper, so the AtomicClock part of the struct will be never
destroyed.

But do not declare every destructor virtual: If a class does not
contain virtual functions, it is not meant to be used as a base class.
DO NOT use virtual destructor for it. Because:
\begin{itemize}
\item virtual requires the objects carry information that can be used
  at runtime to determine which virtual function to invoke. It will
  increase the size.
\item it is not the same as the counterpart in C, not portable.
\end{itemize}

Never call virtual functions during construction or destruction.
Because during base construction, virtual functions never go down into
the derived class.

\paragraph{Virtual vs. Non-Virtual}

Without ~virtual~ you get **early binding**. Which implementation of
the method is used gets decided at **compile time based on the type of
the pointer that you call through**.

With ~virtual~ you get **late binding**. Which implementation of the
method is used gets decided at **run time based on the type of the
pointed-to object** - what it was originally constructed as. This is
not necessarily what you'd think based on the type of the pointer that
points to that object.

\begin{lstlisting}
 class Base
 {
 public:
   void Method1 ()  {  std::cout << "Base::Method1" << std::endl;  }
   virtual void Method2 ()  {  std::cout << "Base::Method2" << std::endl;  }
 };

 class Derived : public Base
 {
 public:
   void Method1 ()  {  std::cout << "Derived::Method1" << std::endl;  }
   void Method2 ()  {  std::cout << "Derived::Method2" << std::endl;  }
 };

 Base* obj = new Derived ();
 //  Note - constructed as Derived, but pointer stored as Base*

 obj->Method1 ();  //  Prints "Base::Method1"
 obj->Method2 ();  //  Prints "Derived::Method2"
\end{lstlisting}

\paragraph{Virtual vs. Pure Virtual}
\begin{itemize}
\item virtual function ~can~ be overriden
\item the pure virtual ~must~ be implemented in non-abstract class
\end{itemize}

\subsubsection{Inheritance}

\paragraph{public inheritance}
"is-a" relation.

Private inheritance means "is-implemented-in-terms-of".  Private
inheritance means nothing during software design, only during software
implementation.  Means Derived objects are implemented in terms of
Base objects, nothing more.

Composition means either "has-a" or "is-implementated-in-terms-of".

\paragraph{hide method}

\begin{lstlisting}
 class Base {
 private:
   int x;
 public:
   virtual void mf1() = 0;
   virtual void mf1(int);

   virtual void mf2();

   void mf3();
   void mf3(double);
 };
 class Derived : public Base {
 public:
   // using Base::mf1; // making all things in Base named mf1 and mf3
   // using Base::mf3; // visible and public in Derived's scope
   virtual void mf2() {  // forwarding function
     Base::mf1();
   }
   virtual void mf1();
   void mf3();
   void mf4();
 };
\end{lstlisting}

the ~mf3~ in Derived will hide both of the ~mf3~ in Base.  The
rationale behind this behavior is that it prevents you from
accidentally inheriting overloads from distant base classes when you
create a new derived class in a library or application framework.

\paragraph{make it visible}
\begin{itemize}
\item ~using~ declarations
\item forwarding functions
\end{itemize}

\subsubsection{Overload}
Same name but different signature.
\begin{lstlisting}
 void print(int i) {
   cout << "Printing int: " << i << endl;
 }
 void print(double  f) {
   cout << "Printing float: " << f << endl;
 }
 void print(char* c) {
   cout << "Printing character: " << c << endl;
 }
\end{lstlisting}

Operator Overload

\begin{lstlisting}
inline bool operator==(Date a, Data b) {
  return a.day() == b.day() && a.month() == b.month() && a.year() == b.year();
}

bool operator!=(Date, Date);
bool operator<(Date, Date)
bool operator>(Date, Date)

Date& operator++(Date &d);
Date& operator--(Date &d);
Date& operator+=(Date &d, int n);
Date& operator-=(Date &d, int n);

Date operator+(Date d, int n);
Date operator-(Date d, int n);

ostream& operator<<(ostream&, Date d);
istream& operator>>(istream&, Date &d);
\end{lstlisting}

\subsubsection{Polymorphism}
It is the ability to redefine methods for derived classes.

\begin{lstlisting}
 class Polygon {
 protected:
   int width, height;
 public:
   void set_values (int a, int b)
   { width=a; height=b; }
 };
 class Rectangle: public Polygon {
 public:
   int area()
   { return width*height; }
 };
 class Triangle: public Polygon {
 public:
   int area()
   { return width*height/2; }
 };
\end{lstlisting}

\paragraph{Static Polymorphism}
The /Curiously Recurring Template Pattern (CRTP)/ is an idiom in C++
in which a class X derives from a class template instantiation using X
itself as template argument
\href{https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern}.
It is also known as /F-bound polymorphism/\cite{canning1989f}.  One of
the use case of CRTP is static polymorphism.  Generally speaking, I
have a base class and some derived class, and I want to have a
~~static virtual'' function that is implemented differently in
different subclasses.  I think such ~~static virtual function'' does
not exist.  But we can simulate it.

\begin{lstlisting}
   template <class T> 
   struct Base {
     void interface() {
       // ...
       static_cast<T*>(this)->implementation();
       // ...
     } 
     static void static_func() {
       // ...
       T::static_sub_func();
       // ...
     }
   };

   struct Derived : Base<Derived> {
     void implementation();
     static void static_sub_func();
   };
\end{lstlisting}


\subsubsection{non-member function}

\begin{lstlisting}
 void clearBrowser(WebBrowser& wb) {
   wb.clearCache();
   wb.clearHistory();
   wb.removeCookies();
 }
 class WebBrowser {
 public:
   void clearCache();
   void clearHistory();
   void removeCookies();
   void clearEverything();
 };
\end{lstlisting}

Prefer use the non-member function, because then less function can
have access to private data, thus better encapsulate.

\paragraph{A common pattern}

Putting all convenience functions in multiple header files, but one
namespace.

~webbrowser.h~

\begin{lstlisting}
 namespace WebBrowserStuff {
   class WebBrowser {...};
   void clearBrowser(WebBrowser& wb);
   // ...
 }
\end{lstlisting}

 ~webbrowserbookmarks.h~

\begin{lstlisting}
 namespace WebBrowserStuff {
   // bookmark related functions
 }
\end{lstlisting}

\subsubsection{friendship}
\paragraph{Friend function}
private and protected member cannot be accessed outside the class, except friends.

\begin{lstlisting}
 class A {
 public:
   friend A func(A a); // declare friend
 private:
   int m;
 };
 A func(A& a) {
   A res;
   res.m = a.m; // access both param and return value
   return res;
 }
\end{lstlisting}

\paragraph{Friend Class}
a class whose member functions can access private and protected member
of another class.

\begin{lstlisting}
 class Rectangle {
   int width, height;
 public:
   int area () {}
   void convert (Square a) {
     width = a.side; // access side in Square
     height = a.side;
   }
 };

 class Square {
   friend class Rectangle; // friend declaration
 private:
   int side;
 public:
   Square (int a) : side(a) {}
 };
\end{lstlisting}
\subsubsection{Nested Class}
\begin{lstlisting}
class enclose {
    class nested1; // forward declaration
    class nested2; // forward declaration
    class nested1 {}; // definition of nested class
};
class enclose::nested2 { }; // definition of nested class
\end{lstlisting}
\begin{itemize}
\item The nested class can access private and protected member of the
  enclosing class, but have separate ~this~ pointer.
\item The friend of the nested class cannot access private and
  protected member of the enclosing class.
\end{itemize}




\subsection{reference vs. value}
A good writeup: \href{http://thbecker.net/articles/rvalue_references/section_01.html}{name}

The original definition for C:
\begin{quote}
An lvalue is an expression e that may appear on the left or on the right hand side of an assignment,
whereas an rvalue is an expression that can only appear on the right hand side of an assignment.
\end{quote}

The changed definition for C++:
\begin{quote}
An lvalue is an expression that refers to a memory location and allows us to take the address of that memory location via the \& operator.
An rvalue is an expression that is not an lvalue.
\end{quote}

\subsubsection{Pass-by Problems}
Pass-by-value has two problems.  Apart from copy problem, there's also
a slicing problem, i.e. when a derived class object is passed by value
as a base class object, the base class constructor is called, thus the
part of the subclass outside the base class will be sliced away.

Also do /NOT/ just pass by value because the struct seems to be small.
\begin{itemize}
\item it can be large, by inheritance
\item the copy constructor may be costly: a object contain little more
  than a pointer, but the constructor will copy everything they point
  to.
\item some compiler treat built-in type and structure differently.
  Some will refuse to put a struct that only contains a double into
  register, but it will surely put a double into register.
\end{itemize}
So some situation pass by value is more efficient though:
\begin{itemize}
\item built-in type(e.g. int)
\item iterators and function objects in STL, they are designed to pass by value
\end{itemize}

On the other hand, reference is often implemented as pointer.
However, there're situations where you have no way but to return a
value.  Return a stack local variable as a reference does not make
sense becasue the variable will not exist outside the function.  When
you return a heap variable, be careful. E.g. in a ~operator*~ method,
return a heap variable is a disaster.  ~w = x * y * z;~ the result of
~x*y~ will never be free-d.
\subsubsection{rvalue and lvalue}
\begin{lstlisting}
     ______ ______
   /       X      \
  /       / \      \
 |   l   | x |  pr  |
  \       \ /      /
   \______ X______/
       gl    r
\end{lstlisting}
\paragraph{lvalue}
 An /lvalue/ is an expression that identifies a non-temporary object or a non-member function.
  * The name of a variable or function in scope
  * Function call or overloaded operator expression if the function's or overloaded operator's return type is an lvalue reference
  * string literal
 A /glvalue/ (~~generalized'' lvalue) is an lvalue or an xvalue.
\paragraph{rvalue}
 An /rvalue/ is an expression that is either a prvalue or an xvalue.
 A /prvalue/ (~~pure'' rvalue) is an rvalue that is not an xvalue.
\paragraph{prvalue}
 A prvalue ("pure" rvalue) is an expression that identifies a temporary object (or a subobject thereof)
 or is a value not associated with any object.
  * literal(except string literal): 42, true
  * the result of calling a function whose return type is not a reference is a prvalue.
\paragraph{xvalue}
 An ~xvalue~ (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example).
 An xvalue is the result of certain kinds of expressions involving rvalue references.
 E.g. the result of calling a function whose return type is an rvalue reference is an xvalue.

\subsubsection{rvalue reference}
 C++11 introduce /ravlue reference/ to enable /move semantic/.
 std::vector<T> is essentially a C-style array and the size.
 Say a std::vector<T> temporary is created or returned from a function.
 To accept the return value, a new vector should be created, and all the internal C-array will be copied.
 When using a /move constructor/,
 it takes the rvalue reference of the temporary vector (\verb$vector<>&&$),
 and copy the /pointer/ to the internal C-style array /out of/ the rvalue into the new vector,
 than set the pointer inside the temporary vector to NULL.
 Since the temporary vector is about to expire, and no one would use it any more,
 it is safe.
 And since the pointer is NULL, no space will be freed upon deconstructing the temporay vector.

Rvalue Reference is important because it supports the implementation of /move constructor/ (enable move semantic) and /perfect forwarding/.
We discuss perfect forwarding here.

\paragraph{The move semantic and swap}
\begin{lstlisting}
template <class T>
typename remove_reference<T>::type&& move (T&& arg) noexcept;

template <class T> void swap (T& a, T& b)
{
  T c(std::move(a)); a=std::move(b); b=std::move(c);
}
template <class T, size_t N> void swap (T &a[N], T &b[N])
{
  for (size_t i = 0; i<N; ++i) swap (a[i],b[i]);
}
\end{lstlisting}

Example
\begin{lstlisting}
// move takes an object, invalidate it, and return the rvalue.
std::string bar = "bar-string";
myvector.push_back (std::move(bar));
// Now bar is valid but has no valid content, while the vector contains the string.
\end{lstlisting}

\paragraph{Perfect Forwarding}
Perfect forwarding reduces the need for overloaded functions and helps
avoid the forwarding problem.  The forwarding problem can occur when
you write a generic function that takes references as its parameters
and it passes (or forwards) these parameters to another function.  For
example, if the generic function takes a parameter of type const T\&,
then the called function cannot modify the value of that parameter.
If the generic function takes a parameter of type T\&, then the
function cannot be called by using an rvalue (such as a temporary
object or integer literal).

Ordinarily, to solve this problem, you must provide overloaded
versions of the generic function that take both T\& and const T\& for
each of its parameters.  As a result, the number of overloaded
functions increases exponentially with the number of parameters.  (For
instance the following code, to write a generic ~factory~ function, we
need to try all combination of ~const T\&~ and ~T\&~ for every type pair
of ~W,X,Y,Z~).  Rvalue references enable you to write one version of a
function that accepts arbitrary arguments and forwards them to another
function as if the other function had been called directly.

For example, following code
\begin{lstlisting}
  struct W {
    W(int&, int&) {}
  };
  struct X {
    X(const int&, int&) {}
  };
  struct Y {
    Y(int&, const int&) {}
  };
  struct Z {
    Z(const int&, const int&) {}
  };

  // Version 1
  template <typename T, typename A1, typename A2>
  T* factory(A1& a1, A2& a2) {
    return new T(a1, a2);
  }
  int a = 4, b = 5;
  W* pw = factory<W>(a, b);
  Z* pz = factory<Z>(2, 2); // error
  // Version 2: using R reference
  template <typename T, typename A1, typename A2>
  T* factory(A1&& a1, A2&& a2) {
    return new T(std::forward<A1>(a1), std::forward<A2>(a2));
  }
  Z* pz = factory<Z>(2, 2); // correct
\end{lstlisting}

std::forward function forwards the parameters of the factory function
to the constructor of the template class.

\paragraph{Other properties}
\begin{itemize}
\item The compiler treats a named rvalue reference as an lvalue and an unnamed rvalue reference as an rvalue.
\item You can cast an lvalue to an rvalue reference. \verb$static_cast<MemoryBlock&&>(block)$
\end{itemize}
For detail, refer to Rvalue Reference
\footnote{\href{https://msdn.microsoft.com/en-us/library/dd293668.aspx}{Rvalue
    Reference}} by Microsoft.


\subsection{lambda}
 Constructs a closure: an unnamed function object capable of capturing variables in scope.

\subsubsection{syntax}

Full declaration:

\begin{lstlisting}
[ capture-list ] ( params ) mutable(optional) exception attribute -> ret { body }
\end{lstlisting}

Declaration of a const lambda: the objects captured by copy cannot be modified.

\begin{lstlisting}
[ capture-list ] ( params ) -> ret { body }
\end{lstlisting}

for example

\begin{lstlisting}
[]()->int { return 2; }
\end{lstlisting}

Omitted trailing-return-type

\begin{lstlisting}
[ capture-list ] ( params ) { body }
\end{lstlisting}

if the ~body~ contains nothing but a single return statement, the return type is that expression's type. Otherwise return type is ~void~.

Omitted parameter list

take no parameters.

\begin{lstlisting}
[ capture-list ] { body }
\end{lstlisting}
\subsubsection{Explanations}
\begin{description}
\item [mutable] allows body to modify the parameters captured by copy, and to call their non-const member functions
\item [exception] provides the exception specification or the noexcept clause for operator() of the closure type
\item [attribute] provides the attribute specification for operator() of the closure type
\item [capture-list] a comma-separated list of zero or more captures
  \begin{description}
  \item [[a,\&b]] where a is captured by value and b is captured by reference.
  \item [[this]] captures the this pointer by value
  \item [[\&]] captures all automatic variables odr-used in the body of the lambda by reference
  \item [[=]] captures all automatic variables odr-used in the body of the lambda by value
  \item [[]] captures nothing
  \end{description}
\end{description}

\subsection{Smart Pointer}

\begin{lstlisting}
std::unique_ptr<Type> ptr; // ensure that the pointer is deleted after going out of scope.
\end{lstlisting}




\subsection{Library: Stream}
\subsubsection{file stream}

\begin{lstlisting}
 #include <fstream>
 ofstream myfile;
 myfile.open("a.txt");
 if (myfile.is_open()) {
   myfile << "...";
   myfile.close();
 }
 // after close, it can used to open another file
 myfile.open("b.txt");
 myfile.close();
\end{lstlisting}

When to flush
\begin{itemize}
\item file.close()
\item buffer is full
\item flush~, ~endl~ used as manipulators
\item file.sync()~
\end{itemize}

mode: open flag:

\begin{tabular}{ll}
  flag & desription\\
  \hline
  ios::in & input\\
  ios::out & output\\
  ios::binary & binary mode\\
  ios::ate & initial position to the end of file\\
  ios::app & all \textbf{\textbf{output}} operations are performed at the end of the file, append\\
  ios::trunc & if the file is opened for output and already exists, previous content is replaced\\
\end{tabular}

Default:

\begin{tabular}{lll}
  class & default mode & New flag action\\
  \hline
  ofstream & ios::out & add\\
  ifstream & ios::in & add\\
  fstream & ios::in 1 ios::out & overwrite\\
\end{tabular}

 binary mode cannot use \verb$>>$, \verb$<<$, getline, but use

\begin{lstlisting}
 write(memory_block, size);
 read(memory_block, size);
\end{lstlisting}

seek
\begin{description}
\item [tellg()] get position
\item [tellp()] put position
\item [seekg(position)] count from the beginning
\item [seekp(position)]
\item [seekg(offset, direction);]
\item [seekp(offset, direction);]
\end{description}

direction
\begin{description}
\item [ios::beg] beginning
\item [ios::cur] current
\item [ios::end] end
\end{description}
\subsubsection{iostream}

\begin{lstlisting}
 #include <iostream>
 int price;
 cin>>price;
\end{lstlisting}

If the input is not integer, the program will **continue** without
setting price's value.  Then if a is used afterwards, undefined
behavior.

To add a validation process, we need to use stringstream:

\begin{lstlisting}
 #include <sstream>
 string mystr;
 getline(cin, mystr);
 stringstream ss = stringstream(mystr);
 // validate ss
 int price;
 ss >> price;
\end{lstlisting}

*Always use getline instead of cin directly*

\begin{lstlisting}
 while(getline(cin, line)) {;}
 while(getline(fs, line)) {;}
\end{lstlisting}


\subsection{String}
\subsubsection{Constructor}

\begin{lstlisting}
 // default
 string();
 // copy
 string (const string& str);
 // substring
 string (const string& str, size_t pos, size_t len = npos);
 // from c-string
 string (const char* s);
 // from sequence
 string (const char* s, size_t n);
 // fill
 string (size_t n, char c);
 // range
 template <class InputIterator>
 string  (InputIterator first, InputIterator last);
\end{lstlisting}

\subsubsection{operator=}

\begin{lstlisting}
 // string
 string& operator= (const string& str);
 // c-string
 string& operator= (const char* s);
 // character
 string& operator= (char c);
\end{lstlisting}
\subsubsection{handy routine}

\paragraph{trim a string}

\begin{lstlisting}
 #include <algorithm>
 #include <functional>
 #include <cctype>
 #include <locale>

 // trim from start
 static inline std::string &ltrim(std::string &s) {
   s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
   return s;
 }

 // trim from end
 static inline std::string &rtrim(std::string &s) {
   s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
   return s;
 }

 // trim from both ends
 static inline std::string &trim(std::string &s) {
   return ltrim(rtrim(s));
 }
\end{lstlisting}

\paragraph{split a string}

\begin{lstlisting}
 string s("Somewhere down the road");
 istringstream iss(s);

 do
 {
   string sub;
   iss >> sub;
   cout << "Substring: " << sub << endl;
 } while (iss);
\end{lstlisting}

\begin{lstlisting}
 std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
   std::stringstream ss(s);
   std::string item;
   while (std::getline(ss, item, delim)) {
     elems.push_back(item);
   }
   return elems;
 }


 std::vector<std::string> split(const std::string &s, char delim) {
   std::vector<std::string> elems;
   split(s, delim, elems);
   return elems;
 }
\end{lstlisting}

More flexible version:
\begin{lstlisting}
/**
 * Delim by ANY characters in delim string
 */
std::vector<std::string>
utils::split(std::string s, std::string delim) {
  std::size_t prev = 0, pos;
  std::vector<std::string> ret;
  while ((pos = s.find_first_of(delim, prev)) != std::string::npos)
    {
      if (pos > prev)
        ret.push_back(s.substr(prev, pos-prev));
      prev = pos+1;
    }
  if (prev < s.length()) {
    ret.push_back(s.substr(prev, std::string::npos));
  }
  return ret;
}
\end{lstlisting}

\paragraph{better split string}
\begin{lstlisting}
 // to std::cout
 copy(
   istream_iterator<string>(iss),
   istream_iterator<string>(),
   ostream_iterator<string>(cout, "\n")
 );
 // to a vector
 vector<string> tokens;
 copy(
   istream_iterator<string>(iss),
   istream_iterator<string>(),
   back_inserter(tokens)
 );
 // construct the vector directly
 vector<string> tokens{
   istream_iterator<string>{iss},
   istream_iterator<string>{}
 };
\end{lstlisting}

\subsubsection{member function}
\begin{description}
\item [begin()]
\item [end()]
\item [size()] length of string
\item [length()] length of string
\item [empty()]
\item [clear()]
\item [{operator[]}]
\item [at()]
\item [back()] A reference to the last character in the string
\item [operator+=]
\item [append]
\item [push\_back(char)] \verb$void push_back (char c);$
\item [insert()] before the character indicated by pos (or p)
\item [erase()] erase part of the string
\item [replace()]
\item [c\_str()] A program **shall not alter** any of the characters in
  this sequence.
\item [copy()] Copies a substring of the current value of the string
  object into the array pointed by s.  **does not append
  null-terminator**
\item [find()] the first occurrence of the sequence specified after pos
\item [substr()] Returns a newly constructed string object with its
  value initialized to a copy of a substring of this object
\item [compare()] return: 0, -, +
\item [npos] max value of \verb$size_t$ \verb$static const size_t npos = -1;$
\end{description}

\subsubsection{non-member function}


\verb$>>$: extract string from stream
\begin{lstlisting}
 istream& operator>> (istream& is, string& str);
 ostream& operator<< (ostream& os, const string& str);
\end{lstlisting}

getline: get line from stream into string
\begin{lstlisting}
 istream& getline (istream& is, string& str, char delim); // delim
 istream& getline (istream& is, string& str); // new line
\end{lstlisting}



\subsection{Tips}
\begin{itemize}
\item \texttt{-Wall}
\item \verb$cin>>a$ encounter \verb$EOF$ or \verb$<C-D>$ returns false
\end{itemize}

\paragraph{auto}
\texttt{g(-1,-2)} equals calls f, with \verb$_1$ replaced with
the positional argument to g.
\begin{lstlisting}
auto g = bind(f, a, b, _2, c, _1);
\end{lstlisting}

\paragraph{decltype}
\begin{lstlisting}
 struct A {
   double x;
 };
 const A* a = new A{0};

 decltype( a->x ) x3;       // type of x3 is double (declared type)
 decltype((a->x)) x4 = x3;  // type of x4 is const double& (lvalue expression)

 auto f = [](int a, int b) -> int {
   return a*b;
 };

 decltype(f) f2 = f; // the type of a lambda function is unique and unnamed
\end{lstlisting}

\paragraph{pair}
\verb$std::make_pair$
\begin{lstlisting}
 template <class T1,class T2>
 pair<T1,T2> make_pair (T1 x, T2 y)
 {
   return ( pair<T1,T2>(x,y) );
 }
\end{lstlisting}
for example:

\begin{lstlisting}
std::make_pair("hello", "world");
\end{lstlisting}

equals to:

\begin{lstlisting}
std::pair<string, string>("hello", "world");
\end{lstlisting}

\paragraph{constant}
Prefer ~const~, ~enum~, and ~inline~ to \verb$#define$.

Rationale
\begin{enumerate}
\item prefer the compiler to preprocessor, the define may never be
  seen by compiler, thus less meaningful debug information, less
  optimization.
\item \verb$#define$ don't respect scope.
\end{enumerate}

Usage:

const

\begin{lstlisting}
 const char* const name = "Hebi Li";
 const std::string name("Hebi Li");
 class A {
 private:
   static const int num = 5;
 };
\end{lstlisting}

data and pointer const:

\begin{lstlisting}
 char name[] = "Hebi Li";
 char *p = name; // non-const
 const char *p = name; // const data
 char* const p = name; // const pointer
 // data     pointer
 const char* const p = name; // double const
\end{lstlisting}

const return value of operator:

\begin{lstlisting}
 const A A::operator*(const A& lhs, const A& rhs);
 if (a*b = c) ... // ERROR assign c to a*b
\end{lstlisting}

\begin{lstlisting}
 char& B::operator[](std::size_t position);
 B b[];
 b[0] = 'x'; // need & in return value, or this assignment can't work because assign to a char
\end{lstlisting}

enums: Some compilers don't support to init value at definition,
because they insist they need to get the when compiling the class.  In
this case, use \textit{enum hack}:

\begin{lstlisting}
 class A {
 private:
   enum {Num = 5}; // the enum hack: make Num a symbolic name for 5
 };
\end{lstlisting}
inlines: replace

\begin{lstlisting}
#define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
\end{lstlisting}

with
\begin{lstlisting}
 template<typename T> inline void callWithMax(const T& a, const T& b) {
   f(a>b?a:b);
 }
\end{lstlisting}

Because you need worry about the parenthesize for define:

\begin{lstlisting}
 int a=5,b=0;
 CALL_WITH_MAX(++a, b); // a increased twice
 CALL_WITH_MAX(++a, b+10); // a increased once
\end{lstlisting}

\paragraph{undefined behavior}
\begin{lstlisting}
 int *p = 0; // null pointer
 std::cout << *p; // UNDEFINED dereferencing a null pointer
 char name[] = "Carla";
 char c = name[10]; // UNDEFINED invalid array index
\end{lstlisting}
They most come from pointer and address.
 \subsection{Function}
function object: Objects that act like functions.  Such objects come
from classes that overload ~operator()~.






 


\subsection{Best Practices}
\subsubsection{compilation dependence}

 The change of a single class can lead to a large amount of file to recompile,
 because:
\begin{itemize}
\item Inheritance
\item Use another class inside a class
\end{itemize}

\subsubsection{Forward-declaration doesn't work.}
\begin{lstlisting}
 int main() {
   int x;
   Person p(params);
 }
\end{lstlisting}
 Forward-declaration cannot make it because this is a define,
 compiler need to know the size.

\subsubsection{Why Java don't have such problem?}
 Java treat the above code as

\begin{lstlisting}
 int main() {
   int x;
   Person * p;
 }
\end{lstlisting}

\paragraph{Solution 1: pimpl(Pointer to implementation)}
In C++, we can of course play the "hide the object implementation
behind a pointer" game ourself.

The key: \textit{replacement of dependencies on definitions with
  dependencies on declarations.}

\begin{itemize}
\item avoid using objects when object references and pointers will do
\item depend on class declarations instead of class definitions whenever you can
\end{itemize}

Note: you never need a class definition to declare a function using
that class, not even if the function passes or returns the class type
by value:

\begin{lstlisting}
 class Date;
 Date today();
 void clearAppointment(Date d);
\end{lstlisting}

Because if anybody calls those functions, Date's definition must have
been seen prior to the call.  So it is not that nobody calls them,
it's that not everybody calls them.

provide separate header flies for declarations and definitions Classes
that employ the pimpl idiom are often called Handle Classes.

\begin{lstlisting}
 #include <string>
 #include <memory>
 class PersonImpl; // forward decl
 class Date;
 class Address;
 class Person {
 public:
   Person(const std::string& name, const Date& birthday, const Address& addr);
   std::string name() const;
   std::string birthDate() const;
   std::string address() const;
 private:
   std::shared_ptr<PersonImpl> pImpl;
 };
\end{lstlisting}
\begin{lstlisting}
 #include "Person.h"
 // we need include PersonImpl.h in order to call the member function
 // PersonImpl has exactly the same API
 #include "PersonImpl.h"
 Person::Person(const std::string& name, const Date& birthday, const Address& addr)
 : pImpl(new PersonImpl(name, birthday, addr)) {}

 std::string Person::name() const {
   return pImpl->name();
 }
\end{lstlisting}

\paragraph{Solution 2: Interface Class}
The implementation of non-virtual functions should be the same for all
classes in a hierarchy, so it makes sense to implement such functions
as part of the Interface class.
\begin{lstlisting}
 class Person {
 public:
   virtual ~Person();
   virtual std::string name() const = 0;
   virtual std::string birthDate() const = 0;
   virtual std::string address() const = 0;

   static std::shard_ptr<Person>
   create(const std::string& name, const Date& birthday, const Address& addr);
 };
 std::shared_ptr<Person>
 create(const std::string& name, const Date& birthday, const Addrss& addr) {
   return std::shared_ptr<Person>(new RealPerson(name, birthday, addr));
 }
\end{lstlisting}

\begin{lstlisting}
 class RealPerson : public Person {
 public:
   RealPerson(const std::string& name, const Date& birthday, const Address& addr)
   : theName(name), theBirthDate(birthday), theAddress(addr) {}
   virtual ~RealPerson() {}

   std::string name() const; // implement
   std::string birthDate() const;
   std::string address() const;
 private:
   std::string theName;
   Date theBirthDate;
   Address theAddress;
 };
\end{lstlisting}

 Clients of interface class need not recompile unless the Interface class's interface is modified.
\subsubsection{coding standards}

\paragraph{header format}
C++ standard library is guaranteed to have 18 standard headers from C.
Two type of names: \verb$<cxxx>$ and \verb$<xxx.h>$

\begin{description}
\item [<cxxx>] provide in the ~std~ namespace only
\item [<xxx.h>] make them available in both ~std~ and global. **Deprecated**
\end{description}

\paragraph{using}
\begin{itemize}
\item using-directive: ~using namespace std;~. Do not use.
\item using-declaration: ~using std::cout;~. Can be used just as a
  statement, e.g. in a function.
\end{itemize}

\paragraph{where to declare variables}
Declare near the first use.

If you don't have enough information to initialize an object until the
middle of the code, create it there.  Don't initialize it to empty and
reassign it later, because performance.

\paragraph{some lint-like guidelines}
\begin{itemize}
\item A class ~Fred~’s assignment operator should return ~*this~ as a
  \verb$Fred&$ (allows chaining of assignments)
\item A class with any virtual functions ought to have a virtual
  destructor
\item A class with any of the following generally needs all 5
  \begin{itemize}
  \item destructor
  \item copy assignment operator
  \item copy constructor
  \item move assignment operator
  \item move constructor
  \end{itemize}
\item A class ~Fred~’s copy constructor and assignment operator should
  have const in the parameter: respectively
  \verb$Fred::Fred(const Fred&)$ and
  \verb$Fred& Fred::operator= (const Fred&)$
\item When initializing an object’s member objects in the constructor,
  always use initialization lists rather than assignment. 3x
  performance.
\item Assignment operators should make sure that self assignment does
  nothing, otherwise you may have a disaster
\end{itemize}

\paragraph{some crazy unix abbr}
 ~abbr evthng n sght, usng vry shrt idntfr nms~

\subsection{C++ Standards}
\subsubsection{C++11}
\paragraph{Default and Delete}
The common idiom of "prohibiting copying" can now be expressed directly:
\begin{lstlisting}
  class X {
    // ...
    X& operator=(const X&) = delete;        // Disallow copying
    X(const X&) = delete;
  };
\end{lstlisting}

Conversely, we can also say explicitly that we want to default copy behavior:
\begin{lstlisting}
  class Y {
    // ...
    Y& operator=(const Y&) = default;       // default copy semantics
    Y(const Y&) = default;
  };
\end{lstlisting}

The "default" mechanism can be used for any function that has a
default.  The "delete" mechanism can be used for any function.  But,
just use them on copy constructor and assignment operator.

%%% Local Variables:
%%% TeX-master: "cheatsheet"
%%% End:
